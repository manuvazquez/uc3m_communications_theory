# AUTOGENERATED! DO NOT EDIT! File to edit: 40_analog.ipynb (unless otherwise specified).

__all__ = ['fft_modulus', 'find_bandwidth', 'passband_filter', 'normalize', 'upper_envelope', 'AmplitudeModulation',
           'FrequencyModulation', 'modulation_index']

# Cell
import pathlib
from typing import List, Union, Tuple

import numpy as np
import scipy.fft
import scipy.signal
import matplotlib.pyplot as plt
import fastcore.foundation

from ipywidgets import interact, interactive, fixed, interact_manual

# Cell
def fft_modulus(signal: np.ndarray, f_s: float, only_positive: bool = False) -> np.ndarray:

    f = scipy.fft.fftfreq(len(signal), 1./f_s)
    y = np.abs(scipy.fft.fft(signal))

    N = len(signal) if not only_positive else len(signal) // 2

    return f[:N], y[:N]

# Cell
def find_bandwidth(signal: np.ndarray, f_s: float, threshold_ratio: float = 1e3) -> float:

    f, fft = fft_modulus(signal, f_s, only_positive=True)

    max_amplitude = np.max(fft)

    i_greater = np.where(fft > max_amplitude / threshold_ratio)[0]

    bw = f[i_greater[-1]] - f[i_greater[0]]

    # Nyquist sampling theorem
    assert bw < f_s / 2

    return bw

# Cell
def passband_filter(signal: np.ndarray, f_s: float, band: list[float, float], order: int = 5) -> np.ndarray:

    nyquist_f = f_s / 2
    b, a = scipy.signal.butter(order, np.array(band) / nyquist_f , btype='band')

    return scipy.signal.lfilter(b, a, signal)

# Cell
def normalize(signal: np.ndarray, return_normalization_constant: bool = False) -> np.ndarray:

    normalization_constant = np.abs(signal).max()

    if return_normalization_constant:

        return signal / normalization_constant, normalization_constant

    else:

        return signal / normalization_constant

# Cell
def upper_envelope(signal: np.ndarray) -> np.ndarray:

    return np.abs(scipy.signal.hilbert(signal))

# Cell
class AmplitudeModulation:

    def __init__(self, Am: float, Ac: float, carrier_freq: float) -> None:

        self.Am = Am
        self.Ac = Ac
        self.carrier_freq = carrier_freq

        # modulation index
        self._m = self.m

    @property
    def m(self) -> float:

        return self.Am / self.Ac

    @m.setter
    def m(self, m) -> None:

        # the modulation index is adjusted by tweaking "Ac"
        self.Ac = self.Am / m

    def modulate(self, time: np.ndarray, information_signal: np.ndarray) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:

        # what multiplies the cosine in the modulated signal (=> what is extracted when there is *no* overmodulation)
        cosine_factor = self.Ac + self.Am * information_signal

        modulated_signal = cosine_factor * np.cos(self.carrier_freq * time)

        envelope = upper_envelope(modulated_signal)

        return modulated_signal, envelope, cosine_factor

    def demodulate(self, modulated_signal: np.ndarray):

        return (upper_envelope(modulated_signal) / self.Ac - 1.) / self.m

    def to_csv(self, time: np.ndarray, information_signal: np.ndarray, output_file: Union[str, pathlib.Path]) -> None:

        modulated_signal, envelope, cosine_factor = self.modulate(time, information_signal)

        data = np.c_[time, information_signal, modulated_signal, envelope, cosine_factor]

        header = f'A_m={Am}, A_c={Ac}, w_c={self.carrier_freq / (2 * np.pi)} Hz\ntime\tmodulating signal\tmodulated signal\tenvelope\tcosine factor'

        np.savetxt(output_file, data, delimiter='\t', header=header)

    # "mpl" stands for matplotlib
    def mpl_plot_modulation(
        self, time: np.ndarray, information_signal: np.ndarray, show_envelop: bool = False,
        figure_size: tuple =(12, 8)):

        modulated_signal, envelope, cosine_factor = self.modulate(time, information_signal)

        fig, ax = plt.subplots(1, 1, figsize=figure_size)
        ax.plot(modulated_signal, label='modulated signal', linestyle='dashed', color='gray')
        ax.plot(information_signal, label='information (modulating) signal')
        if show_envelop:
            ax.plot(envelope, label='envelope')
        ax.legend()

# Cell
class FrequencyModulation:

    def __init__(self, f_s:float, A: float, w_c: float, f_d: float):

        self.f_s = f_s
        self.A = A
        self.w_c = w_c
        self.f_d = f_d

        # sampling frequency should be high enough for the carrier frequency
        assert f_s >= 2 * w_c/(2 * np.pi)

    @property
    def T(self) -> float:

        return 1. / self.f_s

    def modulate(self, t: np.ndarray, information_signal: np.ndarray) -> np.ndarray:

        return self.A*np.cos(self.w_c * t + 2.*np.pi*self.f_d*np.cumsum(information_signal)*self.T)

    def demodulate(self, t: np.ndarray, modulated_signal: np.ndarray):

        yq = scipy.signal.hilbert(modulated_signal) * np.exp(-1j * self.w_c * t)

        return 1./(2*np.pi*self.f_d) * np.r_[np.zeros(1), np.diff(np.unwrap(np.angle(yq)))*self.f_s]

# Cell
@fastcore.foundation.patch
def modulation_index(self: FrequencyModulation, information_signal: np.ndarray) -> float:

    return self.f_d * np.abs(information_signal).max() / find_bandwidth(information_signal, self.f_s)
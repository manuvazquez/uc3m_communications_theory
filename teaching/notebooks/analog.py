# AUTOGENERATED! DO NOT EDIT! File to edit: 40_analog.ipynb (unless otherwise specified).

__all__ = ['normalize', 'upper_envelope', 'AmplitudeModulation']

# Cell

import pathlib
from typing import List, Union

import numpy as np
import scipy.signal
import matplotlib.pyplot as plt

from ipywidgets import interact, interactive, fixed, interact_manual

# Cell

def normalize(signal: np.ndarray) -> np.ndarray:

    return signal / np.abs(signal).max()

# Cell

def upper_envelope(signal: np.ndarray) -> np.ndarray:

    return np.abs(scipy.signal.hilbert(signal))

# Cell

class AmplitudeModulation:

    def __init__(self, Am: float, Ac: float, carrier_freq: float) -> None:

        self.Am = Am
        self.Ac = Ac
        self.carrier_freq = carrier_freq

        # modulation index
        self._m = self.m

    @property
    def m(self) -> float:

        return self.Am / self.Ac

    @m.setter
    def m(self, m) -> None:

        # the modulation index is adjusted by tweaking "Ac"
        self.Ac = self.Am / m

    def modulate(self, time: np.ndarray, information_signal: np.ndarray):

        # what multiplies the cosine in the modulated signal (=> what is extracted when there is *no* overmodulation)
        cosine_factor = self.Ac + self.Am * information_signal

        modulated_signal = cosine_factor * np.cos(self.carrier_freq * time)

#         envelope = np.abs(scipy.signal.hilbert(modulated_signal))
        envelope = upper_envelope(modulated_signal)

        return modulated_signal, envelope, cosine_factor

    def to_csv(self, time: np.ndarray, information_signal: np.ndarray, output_file: Union[str, pathlib.Path]) -> None:

        modulated_signal, envelope, cosine_factor = self.modulate(time, information_signal)

        data = np.c_[time, information_signal, modulated_signal, envelope, cosine_factor]

        header = f'A_m={Am}, A_c={Ac}, w_c={self.carrier_freq / (2 * np.pi)} Hz\ntime\tmodulating signal\tmodulated signal\tenvelope\tcosine factor'

        np.savetxt(output_file, data, delimiter='\t', header=header)

    # "mpl" stands for matplotlib
    def mpl_plot_modulation(self, time: np.ndarray, information_signal: np.ndarray, show_envelop: bool = False, figure_size: tuple =(12, 8)):

        modulated_signal, envelope, cosine_factor = self.modulate(time, information_signal)

        fig, ax = plt.subplots(1, 1, figsize=figure_size)
        ax.plot(modulated_signal, label='modulated signal', linestyle='dashed', color='gray')
        ax.plot(information_signal, label='information (modulating) signal')
        if show_envelop:
            ax.plot(envelope, label='envelope')
        ax.legend()